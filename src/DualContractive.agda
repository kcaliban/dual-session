{-# OPTIONS --rewriting #-}
module DualContractive where

open import Data.Fin
open import Data.Maybe
open import Data.Nat hiding (_‚â§_) renaming (_+_ to _+‚Ñï_)
open import Data.Nat.Properties
open import Data.Sum hiding (map)
open import Data.Product

open import Relation.Nullary
open import Relation.Binary.PropositionalEquality hiding (Extensionality)

open import Function

open import Direction

open import Extensionality

variable
  m n : ‚Ñï
  i j : Fin n 

----------------------------------------------------------------------
-- lemmas for rewriting

n+1=suc-n : n +‚Ñï 1 ‚â° suc n
n+1=suc-n {zero} = refl
n+1=suc-n {suc n} = cong suc (n+1=suc-n {n})

n+0=n : n +‚Ñï 0 ‚â° n
n+0=n {zero} = refl
n+0=n {suc n} = cong suc (n+0=n {n})

n+sucm=sucn+m : ‚àÄ n m ‚Üí n +‚Ñï suc m ‚â° suc (n +‚Ñï m)
n+sucm=sucn+m 0F m = refl
n+sucm=sucn+m (suc n) m = cong suc (n+sucm=sucn+m n m)

{-# REWRITE n+sucm=sucn+m #-}

open import Agda.Builtin.Equality.Rewrite


----------------------------------------------------------------------
module Experimental where

  data CSType (n : ‚Ñï) (i : Fin (suc n)) : Set
  -- contractive session type with n free variables
  -- uses of variables greater than or equal to i are contractive
  -- uses of variables less than i are forbidden

  data CTType (n : ‚Ñï) : Set where
    TInt : CTType n
    TChn : (s : CSType n 0F) ‚Üí CTType n

  data CSType n i where
    xmt : (d : Dir) (t : CTType n) (s : CSType n 0F) ‚Üí CSType n i
    end : CSType n i
    rec : (s : CSType (suc n) (suc i)) ‚Üí CSType n i
    var : (x : Fin n) (i‚â§x : i ‚â§ inject‚ÇÅ x) ‚Üí CSType n i

  impossible : (x : Fin n) ‚Üí ¬¨ from‚Ñï n ‚â§ inject‚ÇÅ x
  impossible 0F ()
  impossible (suc x) (s‚â§s n‚â§x) = impossible x n‚â§x

  module Example where

    s13 : CSType 3 1F
    s13 = var 1F (s‚â§s z‚â§n)
    s12 : CSType 2 0F
    s12 = rec s13
    s11 : CSType 2 2F
    s11 = xmt SND TInt s12
    s10 : CSType 1 1F
    s10 = rec s11

    s1 : CSType 0 0F
    s1 = rec (xmt SND TInt (rec (var 1F (s‚â§s z‚â§n))))

    -- need s1 at type CSType 1 1F
    s1-u1 : CSType 0 0F
    s1-u1 = xmt SND TInt (rec (rec (xmt SND  TInt (rec (var 1F (s‚â§s z‚â§n))))))

  lemma-inject : ‚àÄ x m ‚Üí (i‚â§x : i ‚â§ inject‚ÇÅ x) ‚Üí inject+ m i ‚â§ inject‚ÇÅ (inject+ m x)
  lemma-inject {i = 0F} 0F m z‚â§n = z‚â§n
  lemma-inject {i = 0F} (suc x) m z‚â§n = z‚â§n
  lemma-inject {i = suc i} 0F m ()
  lemma-inject {i = suc i} (suc x) m (s‚â§s i‚â§x) = s‚â§s (lemma-inject x m i‚â§x)

  sweaken0 : ‚àÄ m ‚Üí CSType n i ‚Üí CSType (n +‚Ñï m) (inject+ m i)
  tweaken0 : ‚àÄ m ‚Üí CTType n ‚Üí CTType (n +‚Ñï m)

  sweaken0 m (xmt d t s) = xmt d (tweaken0 m t) (sweaken0 m s)
  sweaken0 m (rec s) = rec (sweaken0 m s)
  sweaken0 m (var x i‚â§x) = var (inject+ m x) (lemma-inject x m i‚â§x)
  sweaken0 m end = end

  tweaken0 m TInt = TInt
  tweaken0 m (TChn s) = TChn (sweaken0 m s)

  tweaken' : ‚àÄ m ‚Üí CTType n ‚Üí CTType (n +‚Ñï m)
  sweaken' : ‚àÄ m ‚Üí CSType n (from‚Ñï n) ‚Üí CSType (n +‚Ñï m) (from‚Ñï (n +‚Ñï m))

  sweaken' m (xmt d t s) = xmt d (tweaken' m t) (sweaken0 m s)
  sweaken' m end = end
  sweaken' m (rec s) = rec (sweaken' m s)
  sweaken' m (var x i‚â§x) with impossible x i‚â§x
  sweaken' m (var x i‚â§x) | ()

  tweaken' m TInt = TInt
  tweaken' m (TChn s) = TChn (sweaken0 m s)

  module revisit-example where

    s1 : CSType 0 0F
    s1 = rec (xmt SND TInt (rec (var 1F (s‚â§s z‚â§n))))

    s1w : CSType 1 1F
    s1w = sweaken' 1 s1

    -- need s1 at type CSType 1 1F
    s1-u1 : CSType 0 0F
    s1-u1 = xmt SND TInt (rec (rec (xmt SND  TInt (rec (var 1F (s‚â§s z‚â§n))))))

    s1-u1w : CSType 0 0F
    s1-u1w = xmt SND TInt (rec s1w)

    u1=u1w : s1-u1 ‚â° s1-u1w
    u1=u1w = refl

  tsubst1 : (j : Fin (suc n)) ‚Üí CSType 0 0F ‚Üí CTType (suc n) ‚Üí CTType n
  ssubst1 : (j : Fin (suc n)) ‚Üí CSType 0 0F ‚Üí i ‚â§ j ‚Üí CSType (suc n) (inject‚ÇÅ i) ‚Üí CSType n i

  ssubst1 j s0 i‚â§j (xmt d t s) = xmt d (tsubst1 j s0 t) (ssubst1 j s0 z‚â§n s)
  ssubst1 j s0 i‚â§j end = end
  ssubst1 j s0 i‚â§j (rec s) = rec (ssubst1 (suc j) s0 (s‚â§s i‚â§j) s)
  ssubst1 {0F} {0F} 0F s0 z‚â§n (var 0F z‚â§n) = s0
  ssubst1 {suc n} {0F} 0F s0 z‚â§n (var 0F z‚â§n) = sweaken0 (suc n) s0
  ssubst1 {suc n} {0F} 0F s0 z‚â§n (var (suc x) z‚â§n) = var x z‚â§n
  ssubst1 {suc n} {0F} (suc j) s0 z‚â§n (var 0F z‚â§n) = var 0F z‚â§n
  ssubst1 {suc n} {0F} (suc j) s0 z‚â§n (var (suc x) z‚â§n)
    with sweaken0 1 (ssubst1 {n} {0F} j s0 z‚â§n (var x z‚â§n))
  ... | ih rewrite n+0=n {n} = ih
  ssubst1 {suc n} {suc i} (suc j) s0 (s‚â§s i‚â§j) (var (suc x) (s‚â§s i‚â§x))
    with ssubst1 {n} {i} j s0 i‚â§j (var x i‚â§x)
  ... | ih = let sw1 = sweaken'{n} 1 in {!sweaken'!}

  tsubst1 j s0 t = {!!}

  tsubst0 : Fin (suc n) ‚Üí CSType 0 0F ‚Üí CTType (suc n) ‚Üí CTType n
  ssubst0 : Fin (suc n) ‚Üí CSType 0 0F ‚Üí CSType (suc n) (inject‚ÇÅ i) ‚Üí CSType n i

  ssubst0 j s0 (xmt d t s) = xmt d (tsubst0 j s0 t) (ssubst0 j s0 s)
  ssubst0 j s0 end = end
  ssubst0 j s0 (rec s) = rec (ssubst0 (suc j) s0 s)
  ssubst0 {n} {0F} 0F s0 (var 0F z‚â§n) = sweaken0 n s0
  ssubst0 {suc n} {0F} (suc j) s0 (var 0F z‚â§n) = var 0F z‚â§n
  ssubst0 {n} {0F} 0F s0 (var (suc x) z‚â§n) = var x z‚â§n
  ssubst0 {suc n} {0F} (suc j) s0 (var (suc x) z‚â§n) 
    with sweaken0 1 (ssubst0 {n} {0F} j s0 (var x z‚â§n))
  ... | ih rewrite n+0=n {n} = ih
  ssubst0 {n} {suc i} j s0 (var 0F ())
  ssubst0 {suc n} {suc i} 0F s0 (var (suc x) (s‚â§s i‚â§x)) = {!!} -- var x {!!}
  ssubst0 {suc n} {suc i} (suc j) s0 (var (suc x) (s‚â§s i‚â§x)) = {!!}

  tsubst0 j s0 TInt = TInt
  tsubst0 j s0 (TChn s) = TChn (ssubst0 j s0 s)

  ssubst' : Fin (suc n) ‚Üí CSType 0 0F ‚Üí CSType (suc n) (from‚Ñï (suc n)) ‚Üí CSType n (from‚Ñï n)

  ssubst' j s0 (xmt d t s) = xmt d (tsubst0 j s0 t) (ssubst0 j s0 s)
  ssubst' j s0 end = end
  ssubst' j s0 (rec s) = rec (ssubst' (suc j) s0 s)
  ssubst' j s0 (var x i‚â§x) with impossible x i‚â§x
  ssubst' j s0 (var x i‚â§x) | ()

  ----------------------------------------------------------------------

  sweaki : j ‚â§ i ‚Üí CSType n i ‚Üí CSType n j
  sweaki i‚â§j (xmt d t s) = xmt d t s
  sweaki i‚â§j (rec s) = rec (sweaki (s‚â§s i‚â§j) s)
  sweaki i‚â§j (var x i‚â§j‚ÇÅ) = var x (‚â§-trans i‚â§j i‚â§j‚ÇÅ)
  sweaki i‚â§j end = end

  -- _+ùîΩ_ : (i : Fin (suc n)) (m : ‚Ñï) ‚Üí Fin (suc (n +‚Ñï m))
  -- _+ùîΩ_ i 0F = i
  -- _+ùîΩ_ i (suc m) = suc (_+ùîΩ_ i m)

  -- liftadd-suc : (i : Fin (suc n)) (m : ‚Ñï) ‚Üí _+ùîΩ_ (suc i) m ‚â° suc (_+ùîΩ_ i m)
  -- liftadd-suc i 0F = refl
  -- liftadd-suc i (suc m) = cong suc (liftadd-suc i m)

  -- -- weakening
  -- sweaken : ‚àÄ m ‚Üí CSType n i ‚Üí CSType (n +‚Ñï m) (i +ùîΩ m)
  -- tweaken : ‚àÄ m ‚Üí CTType n ‚Üí CTType (n +‚Ñï m)

  -- sweaken m (xmt d t s) = xmt d (tweaken m t) (sweaki z‚â§n (sweaken m s))
  -- sweaken {i = i} m (rec s) with sweaken m s
  -- ... | sms rewrite liftadd-suc i m = rec sms
  -- sweaken m (var x i‚â§x) = var (inject+ m x) {!!}
  -- sweaken m end = end

  -- tweaken m TInt = TInt
  -- tweaken m (TChn s) = TChn (sweaki z‚â§n (sweaken m s))


  _+ùîæ_ : (i : Fin (suc n)) (j : Fin (suc m)) ‚Üí Fin (suc (n +‚Ñï m))
  _+ùîæ_{n}{m} i 0F = inject+ m i
  _+ùîæ_{n}{suc m} i (suc j) with i +ùîæ j
  ... | ij rewrite n+sucm=sucn+m n m = suc ij

  suc-i+Gj : (i : Fin (suc n)) (j : Fin (suc m)) ‚Üí suc (i +ùîæ j) ‚â° suc i +ùîæ j
  suc-i+Gj i 0F = refl
  suc-i+Gj{n}{suc m} i (suc j) with suc-i+Gj i j
  ... | sij rewrite n+sucm=sucn+m n m = cong suc sij

  ij‚â§injmx : ‚àÄ m ‚Üí (i : Fin (suc n)) (j : Fin (suc m)) (x : Fin n) (i‚â§x : i ‚â§ inject‚ÇÅ x)
    ‚Üí (i +ùîæ j) ‚â§ inject‚ÇÅ (inject+ m x)
  ij‚â§injmx m 0F j 0F z‚â§n = {!!}
  ij‚â§injmx m 0F j (suc x) z‚â§n = {!!}
  ij‚â§injmx m (suc i) j 0F ()
  ij‚â§injmx m (suc i) j (suc x) (s‚â§s i‚â§x) 
    rewrite sym (suc-i+Gj i j) = s‚â§s (ij‚â§injmx m i j x i‚â§x)

  sweakeni : ‚àÄ m (j : Fin (suc m)) ‚Üí CSType n i ‚Üí CSType (n +‚Ñï m) (i +ùîæ j)
  tweakeni : ‚àÄ m ‚Üí CTType n ‚Üí CTType (n +‚Ñï m)

  sweakeni m j (xmt d t s) = xmt d (tweakeni m t) (sweakeni m 0F s)
  sweakeni m j end = end
  sweakeni{i = i} m j (rec s) with (sweakeni m j s)
  ... | swi rewrite sym (suc-i+Gj i j) = rec swi
  sweakeni m j (var x i‚â§x) = var (inject+ m x) (ij‚â§injmx m _ j x i‚â§x)

  tweakeni m TInt = TInt
  tweakeni m (TChn s) = TChn (sweakeni m 0F s)

  sweakenn : ‚àÄ m (j : Fin (suc (n +‚Ñï m))) ‚Üí CSType n (from‚Ñï n) ‚Üí CSType (n +‚Ñï m) j
  sweakenn m j (xmt d t s) = xmt d {!!} (sweakenn m 0F {!!})
  sweakenn m j end = {!!}
  sweakenn m j (rec s) = {!!}
  sweakenn m j (var x i‚â§x) = {!!}

  ssubst : Fin (suc n) ‚Üí CSType 0 0F ‚Üí CSType (suc n) (inject‚ÇÅ i) ‚Üí CSType n i
  tsubst : Fin (suc n) ‚Üí CSType 0 0F ‚Üí CTType (suc n) ‚Üí CTType n

  ssubst j s‚ÇÄ (xmt d t s) = xmt d (tsubst j s‚ÇÄ t) (ssubst j s‚ÇÄ s)
  ssubst j s‚ÇÄ end = end
  ssubst j s‚ÇÄ (rec s) = rec (ssubst (suc j) s‚ÇÄ s)
  ssubst {n} 0F s‚ÇÄ (var 0F i‚â§x) = {!sweak!}
  ssubst {n} 0F s‚ÇÄ (var (suc x) i‚â§x) = {!!}
  ssubst {n} (suc j) s‚ÇÄ (var 0F i‚â§x) = {!!}
  ssubst {n} (suc j) s‚ÇÄ (var (suc x) i‚â§x) = {!!}

  tsubst j s‚ÇÄ TInt = TInt
  tsubst j s‚ÇÄ (TChn s) = TChn (ssubst j s‚ÇÄ s)


  unfold : (s : CSType n i) (œÉ : CSType n i ‚Üí CSType 0 0F) ‚Üí CSType 0 0F
  unfold (xmt d t s) œÉ = œÉ (xmt d t s)
  unfold (rec s) œÉ = unfold s (œÉ ‚àò {!ssubst!})
  unfold {i = 0F} (var j z‚â§n) œÉ = œÉ (var j z‚â§n)
  unfold {i = suc i} (var 0F ()) œÉ
  unfold {i = suc i} (var (suc j) (s‚â§s i‚â§j)) œÉ = unfold (var j i‚â§j) {!!}
  unfold end œÉ = end

----------------------------------------------------------------------
-- auxiliaries for automatic rewriting

{- REWRITE n+1=suc-n #-}

{-# REWRITE n+0=n #-}

inject+0-x=x : {x : Fin m} ‚Üí inject+ 0 x ‚â° x
inject+0-x=x {x = zero} = refl
inject+0-x=x {x = suc x} = cong suc inject+0-x=x

{-# REWRITE inject+0-x=x #-}

----------------------------------------------------------------------

data TType (n : ‚Ñï) : Set 
data SType (n : ‚Ñï) : Set

data TType n where
  TInt : TType n
  TChn : (s : SType n) ‚Üí TType n

data SType n where
  xmt : (d : Dir) (t : TType n) (s : SType n) ‚Üí SType n
  rec : SType (suc n) ‚Üí SType n
  var : Fin n ‚Üí SType n
  end : SType n

variable
  t : TType n
  s s‚ÇÄ : SType n

----------------------------------------------------------------------
-- weakening

weakenS : ‚àÄ m ‚Üí SType n ‚Üí SType (n +‚Ñï m)
weakenT : ‚àÄ m ‚Üí TType n ‚Üí TType (n +‚Ñï m)

weakenS m (xmt d t s) = xmt d (weakenT m t) (weakenS m s)
weakenS m (rec s) = rec (weakenS m s)
weakenS m (var x) = var (inject+ m x)
weakenS m end = end

weakenT m TInt = TInt
weakenT m (TChn s) = TChn (weakenS m s)

weaken1S : SType n ‚Üí SType (suc n)
weaken1S s = weakenS 1 s

----------------------------------------------------------------------
-- substitution

ssubst : SType (suc n) ‚Üí Fin (suc n) ‚Üí SType 0 ‚Üí SType n
tsubst : TType (suc n) ‚Üí Fin (suc n) ‚Üí SType 0 ‚Üí TType n

ssubst (xmt d t s) i s0 = xmt d (tsubst t i s0) (ssubst s i s0)
ssubst (rec s) i s0 = rec (ssubst s (suc i) s0)
ssubst {n} (var 0F) 0F s0 = weakenS n s0
ssubst {suc n} (var 0F) (suc i) s0 = var 0F
ssubst (var (suc x)) 0F s0 = var x
ssubst {suc n} (var (suc x)) (suc i) s0 = weaken1S (ssubst (var x) i s0)
ssubst end i s0 = end

tsubst TInt i s‚ÇÄ = TInt
tsubst (TChn s) i s‚ÇÄ = TChn (ssubst s i s‚ÇÄ)

----------------------------------------------------------------------
-- contractivity

mutual
  data ContractiveT : TType n ‚Üí Set where
    con-int : ContractiveT{n} TInt
    con-chn : Contractive 0F s ‚Üí ContractiveT (TChn s)

  data Contractive : Fin (suc n) ‚Üí SType n ‚Üí Set where
    con-rec : Contractive (suc i) s ‚Üí Contractive i (rec s)
    con-xmt : ContractiveT t ‚Üí Contractive 0F s ‚Üí Contractive i (xmt d t s)
    con-var : i ‚â§ inject‚ÇÅ j ‚Üí Contractive i (var j)
    con-end : Contractive i end

module Examples where
  cn1 : ¬¨ Contractive {2} 1F (var 0F)
  cn1 (con-var ())

  cp1 : Contractive {2} 0F (var 1F)
  cp1 = con-var z‚â§n

  cp0 : Contractive {2} 0F (var 0F)
  cp0 = con-var z‚â§n

  sp2 : SType 0
  sp2 = (rec (xmt SND TInt (rec (var 1F))))

  cp2 : Contractive 0F sp2
  cp2 = con-rec (con-xmt con-int (con-rec (con-var (s‚â§s z‚â§n))))

  sn2 : SType 0
  sn2 = (rec (xmt SND TInt (rec (var 0F))))

  cn2 : ¬¨ Contractive 0F sn2
  cn2 (con-rec (con-xmt con-int (con-rec (con-var ()))))

unfold : (s : SType n) (c : Contractive i s) (œÉ : SType n ‚Üí SType 0) ‚Üí SType 0
unfold (xmt d t s) (con-xmt ct c) œÉ = œÉ (xmt d t s)
unfold end con-end œÉ = end
unfold (rec s) (con-rec c) œÉ = unfold s c (œÉ ‚àò Œª sn' ‚Üí ssubst sn' 0F (œÉ (rec s))) 
unfold {i = 0F} (var x) (con-var z‚â§n) œÉ = œÉ (var x)
unfold {i = suc i} (var 0F) (con-var ()) œÉ
unfold {i = suc i} (var (suc x)) (con-var (s‚â§s x‚ÇÅ)) œÉ = unfold (var x) (con-var x‚ÇÅ) (œÉ ‚àò weaken1S)

module CheckUnfold where
  s1 : SType 0
  s1 = rec (xmt SND TInt (var 0F))
  c1 : Contractive 0F s1
  c1 = con-rec (con-xmt con-int (con-var z‚â§n))
  s2 : SType 0
  s2 = xmt SND TInt s1

  u-s1=s2 : unfold s1 c1 id ‚â° s2
  u-s1=s2 = refl

  s3 : SType 0
  s3 = rec (rec (xmt SND TInt (var 0F)))
  c3 : Contractive 0F s3
  c3 = con-rec (con-rec (con-xmt con-int (con-var z‚â§n)))
  u-s3=s2 : unfold s3 c3 id ‚â° s2
  u-s3=s2 = refl

infer-contractiveT : (t : TType n) ‚Üí Dec (ContractiveT t)
infer-contractive : (s : SType n) (i : Fin (suc n)) ‚Üí Dec (Contractive i s)

infer-contractive (xmt d t s) i 
  with infer-contractiveT t | infer-contractive s 0F
infer-contractive (xmt d t s) i | yes p | yes p‚ÇÅ = yes (con-xmt p p‚ÇÅ)
infer-contractive (xmt d t s) i | yes p | no ¬¨p = no (Œª { (con-xmt ct cs) ‚Üí ¬¨p cs })
infer-contractive (xmt d t s) i | no ¬¨p | yes p = no (Œª { (con-xmt ct cs) ‚Üí ¬¨p ct })
infer-contractive (xmt d t s) i | no ¬¨p | no ¬¨p‚ÇÅ = no (Œª { (con-xmt ct cs) ‚Üí ¬¨p‚ÇÅ cs})
infer-contractive end i = yes con-end
infer-contractive (rec s) i
  with infer-contractive s (suc i)
infer-contractive (rec s) i | yes p = yes (con-rec p)
infer-contractive (rec s) i | no ¬¨p = no (Œª { (con-rec c) ‚Üí ¬¨p c })
infer-contractive (var x) 0F = yes (con-var z‚â§n)
infer-contractive (var 0F) (suc i) = no (Œª { (con-var ()) })
infer-contractive (var (suc x)) (suc i)
  with infer-contractive (var x) i
infer-contractive (var (suc x)) (suc i) | yes (con-var x‚ÇÅ) = yes (con-var (s‚â§s x‚ÇÅ))
infer-contractive (var (suc x)) (suc i) | no ¬¨p = no (Œª { (con-var (s‚â§s y)) ‚Üí ¬¨p (con-var y) })

infer-contractiveT TInt = yes con-int
infer-contractiveT (TChn s)
  with infer-contractive s 0F
infer-contractiveT (TChn s) | yes p = yes (con-chn p)
infer-contractiveT (TChn s) | no ¬¨p = no (Œª { (con-chn cs) ‚Üí ¬¨p cs })

module ExamplesInference where
  open Examples
  
  infer-p2 : infer-contractive sp2 0F ‚â° yes cp2
  infer-p2 = refl

  -- infer-n2 : infer-contractive sn2 0F ‚â° no cn2
  -- how?


SType' : ‚Ñï ‚Üí Set
SType' n = Œ£ (SType n) (Œª s ‚Üí ‚àÉ Œª i ‚Üí Contractive i s)

unfold' : SType' n ‚Üí (SType n ‚Üí SType 0) ‚Üí SType' 0
unfold' (xmt d t s , i , c) œÉ = œÉ (xmt d t s) , 0F , {!!}
unfold' (rec s , snd) œÉ
  with unfold' (s , {!!}) {!!}
... | usc = {!!}
unfold' (var x , snd) œÉ = (œÉ (var x)) , 0F , {!!}
unfold' (end , i , con-end) œÉ = end , 0F , con-end

----------------------------------------------------------------------
-- equivalence
variable
  t‚ÇÅ t‚ÇÇ t‚ÇÅ' t‚ÇÇ' : TType n
  s‚ÇÅ s‚ÇÇ : SType n

-- type equivalence
data EquivT (R : SType n ‚Üí SType n ‚Üí Set) : TType n ‚Üí TType n ‚Üí Set where
  eq-int  : EquivT R TInt TInt
  eq-chan : R s‚ÇÅ s‚ÇÇ ‚Üí EquivT R (TChn s‚ÇÅ) (TChn s‚ÇÇ)

-- session type equivalence
data EquivS (R : SType n ‚Üí SType n ‚Üí Set) : SType n ‚Üí SType n ‚Üí Set where
  eq-xmt : (d : Dir) ‚Üí EquivT R t‚ÇÅ t‚ÇÇ ‚Üí R s‚ÇÅ s‚ÇÇ ‚Üí EquivS R (xmt d t‚ÇÅ s‚ÇÅ) (xmt d t‚ÇÇ s‚ÇÇ)
  eq-end : EquivS R end end

-- record Equiv (s‚ÇÅ s‚ÇÇ : SType 0) : Set where
--   coinductive
--   field force : EquivS Equiv (unfold s‚ÇÅ) (unfold s‚ÇÇ)

-- open Equiv
